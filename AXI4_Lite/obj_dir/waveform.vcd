$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module TOP $end
  $var wire 1 W ACLK $end
  $var wire 1 X ARESETN $end
  $var wire 1 Y read_s $end
  $var wire 1 Z write_s $end
  $var wire 32 [ address [31:0] $end
  $var wire 32 \ W_data [31:0] $end
  $scope module axi4_lite_top $end
   $var wire 32 ` DATA_WIDTH [31:0] $end
   $var wire 32 ` ADDRESS [31:0] $end
   $var wire 1 W ACLK $end
   $var wire 1 X ARESETN $end
   $var wire 1 Y read_s $end
   $var wire 1 Z write_s $end
   $var wire 32 [ address [31:0] $end
   $var wire 32 \ W_data [31:0] $end
   $var wire 1 # M_ARREADY $end
   $var wire 1 $ S_RVALID $end
   $var wire 1 % M_ARVALID $end
   $var wire 1 & M_RREADY $end
   $var wire 1 ' S_AWREADY $end
   $var wire 1 ( S_BVALID $end
   $var wire 1 ) M_AWVALID $end
   $var wire 1 * M_BREADY $end
   $var wire 1 ) M_WVALID $end
   $var wire 1 ' S_WREADY $end
   $var wire 32 ] M_ARADDR [31:0] $end
   $var wire 32 ^ M_AWADDR [31:0] $end
   $var wire 32 _ M_WDATA [31:0] $end
   $var wire 32 + S_RDATA [31:0] $end
   $var wire 4 , M_WSTRB [3:0] $end
   $var wire 2 a S_RRESP [1:0] $end
   $var wire 2 a S_BRESP [1:0] $end
   $scope module u_axi4_lite_master0 $end
    $var wire 32 ` ADDRESS [31:0] $end
    $var wire 32 ` DATA_WIDTH [31:0] $end
    $var wire 1 W ACLK $end
    $var wire 1 X ARESETN $end
    $var wire 1 Y START_READ $end
    $var wire 1 Z START_WRITE $end
    $var wire 32 [ address [31:0] $end
    $var wire 32 \ W_data [31:0] $end
    $var wire 1 # M_ARREADY $end
    $var wire 32 + M_RDATA [31:0] $end
    $var wire 2 a M_RRESP [1:0] $end
    $var wire 1 $ M_RVALID $end
    $var wire 1 ' M_AWREADY $end
    $var wire 1 ' M_WREADY $end
    $var wire 2 a M_BRESP [1:0] $end
    $var wire 1 ( M_BVALID $end
    $var wire 32 ] M_ARADDR [31:0] $end
    $var wire 1 % M_ARVALID $end
    $var wire 1 & M_RREADY $end
    $var wire 32 ^ M_AWADDR [31:0] $end
    $var wire 1 ) M_AWVALID $end
    $var wire 32 _ M_WDATA [31:0] $end
    $var wire 4 , M_WSTRB [3:0] $end
    $var wire 1 ) M_WVALID $end
    $var wire 1 * M_BREADY $end
    $var wire 1 - read_start $end
    $var wire 1 . write_start $end
    $var wire 3 / state [2:0] $end
    $var wire 3 0 next_state [2:0] $end
   $upscope $end
   $scope module u_axi4_lite_slave0 $end
    $var wire 32 ` ADDRESS [31:0] $end
    $var wire 32 ` DATA_WIDTH [31:0] $end
    $var wire 1 W ACLK $end
    $var wire 1 X ARESETN $end
    $var wire 32 ] S_ARADDR [31:0] $end
    $var wire 1 % S_ARVALID $end
    $var wire 1 & S_RREADY $end
    $var wire 32 ^ S_AWADDR [31:0] $end
    $var wire 1 ) S_AWVALID $end
    $var wire 4 , S_WSTRB [3:0] $end
    $var wire 32 _ S_WDATA [31:0] $end
    $var wire 1 ) S_WVALID $end
    $var wire 1 * S_BREADY $end
    $var wire 1 # S_ARREADY $end
    $var wire 32 + S_RDATA [31:0] $end
    $var wire 2 a S_RRESP [1:0] $end
    $var wire 1 $ S_RVALID $end
    $var wire 1 ' S_AWREADY $end
    $var wire 1 ' S_WREADY $end
    $var wire 2 a S_BRESP [1:0] $end
    $var wire 1 ( S_BVALID $end
    $var wire 32 ` no_of_registers [31:0] $end
    $var wire 32 1 register[0] [31:0] $end
    $var wire 32 2 register[1] [31:0] $end
    $var wire 32 3 register[2] [31:0] $end
    $var wire 32 4 register[3] [31:0] $end
    $var wire 32 5 register[4] [31:0] $end
    $var wire 32 6 register[5] [31:0] $end
    $var wire 32 7 register[6] [31:0] $end
    $var wire 32 8 register[7] [31:0] $end
    $var wire 32 9 register[8] [31:0] $end
    $var wire 32 : register[9] [31:0] $end
    $var wire 32 ; register[10] [31:0] $end
    $var wire 32 < register[11] [31:0] $end
    $var wire 32 = register[12] [31:0] $end
    $var wire 32 > register[13] [31:0] $end
    $var wire 32 ? register[14] [31:0] $end
    $var wire 32 @ register[15] [31:0] $end
    $var wire 32 A register[16] [31:0] $end
    $var wire 32 B register[17] [31:0] $end
    $var wire 32 C register[18] [31:0] $end
    $var wire 32 D register[19] [31:0] $end
    $var wire 32 E register[20] [31:0] $end
    $var wire 32 F register[21] [31:0] $end
    $var wire 32 G register[22] [31:0] $end
    $var wire 32 H register[23] [31:0] $end
    $var wire 32 I register[24] [31:0] $end
    $var wire 32 J register[25] [31:0] $end
    $var wire 32 K register[26] [31:0] $end
    $var wire 32 L register[27] [31:0] $end
    $var wire 32 M register[28] [31:0] $end
    $var wire 32 N register[29] [31:0] $end
    $var wire 32 O register[30] [31:0] $end
    $var wire 32 P register[31] [31:0] $end
    $var wire 32 Q addr [31:0] $end
    $var wire 1 R write_addr $end
    $var wire 1 S write_data $end
    $var wire 3 T state [2:0] $end
    $var wire 3 U next_state [2:0] $end
    $var wire 32 V i [31:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
0#
0$
0%
0&
0'
0(
0)
0*
b00000000000000000000000000000000 +
b0000 ,
0-
0.
b000 /
b000 0
b00000000000000000000000000000000 1
b00000000000000000000000000000000 2
b00000000000000000000000000000000 3
b00000000000000000000000000000000 4
b00000000000000000000000000000000 5
b00000000000000000000000000000000 6
b00000000000000000000000000000000 7
b00000000000000000000000000000000 8
b00000000000000000000000000000000 9
b00000000000000000000000000000000 :
b00000000000000000000000000000000 ;
b00000000000000000000000000000000 <
b00000000000000000000000000000000 =
b00000000000000000000000000000000 >
b00000000000000000000000000000000 ?
b00000000000000000000000000000000 @
b00000000000000000000000000000000 A
b00000000000000000000000000000000 B
b00000000000000000000000000000000 C
b00000000000000000000000000000000 D
b00000000000000000000000000000000 E
b00000000000000000000000000000000 F
b00000000000000000000000000000000 G
b00000000000000000000000000000000 H
b00000000000000000000000000000000 I
b00000000000000000000000000000000 J
b00000000000000000000000000000000 K
b00000000000000000000000000000000 L
b00000000000000000000000000000000 M
b00000000000000000000000000000000 N
b00000000000000000000000000000000 O
b00000000000000000000000000000000 P
b00000000000000000000000000000000 Q
0R
0S
b000 T
b000 U
b00000000000000000000000000000000 V
1W
0X
0Y
0Z
b00000000000000000000000000000000 [
b00000000000000000000000000000000 \
b00000000000000000000000000000000 ]
b00000000000000000000000000000000 ^
b00000000000000000000000000000000 _
b00000000000000000000000000100000 `
b00 a
#1
0W
#2
b00000000000000000000000000100000 V
1W
#3
0W
#4
1W
#5
0W
1X
#6
1W
#7
0W
1Z
b00000000000000000000000000000101 [
b00000000000000000000000000000100 \
#8
1.
b001 0
1W
#9
0W
0Z
#10
1)
1*
b1111 ,
0.
b001 /
b001 U
1W
b00000000000000000000000000000101 ^
b00000000000000000000000000000100 _
#11
0W
#12
1'
b010 0
1R
1S
b001 T
b010 U
1W
#13
0W
#14
0'
1(
0)
b0000 ,
b010 /
b000 0
b00000000000000000000000000000100 6
0R
0S
b010 T
b000 U
1W
b00000000000000000000000000000000 ^
b00000000000000000000000000000000 _
#15
0W
#16
0(
0*
b000 /
b000 T
1W
#17
0W
#18
1W
#19
0W
#20
1W
#21
0W
1Y
#22
1-
b011 0
1W
#23
0W
0Y
#24
1%
1&
0-
b011 /
b011 U
1W
b00000000000000000000000000000101 ]
#25
0W
#26
1#
b100 0
b011 T
b100 U
1W
#27
0W
#28
0#
1$
0%
b00000000000000000000000000000100 +
b100 /
b000 0
b00000000000000000000000000000101 Q
b100 T
b000 U
1W
b00000000000000000000000000000000 ]
#29
0W
#30
0$
0&
b00000000000000000000000000000000 +
b000 /
b000 T
1W
#31
0W
#32
1W
#33
0W
#34
1W
#35
0W
#36
1W
#37
0W
#38
1W
#39
0W
#40
1W
